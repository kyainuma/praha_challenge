# DBモデリング1

## 課題1
- セットメニューとお好み寿司のテーブルを分けた。理由はセットメニューのみに追加仕様がある場合などに変更しやすい
- お好み寿司の価格も寿司テーブルに持たせると同じ価格が何度もあるので別テーブルに切り出した
- 合計皿数は計算で都度求めてテーブルには含めない。現状はいらなそう。追加仕様によっては追加する。たとえばその日の注文一覧を見れる仕様にする際に合計皿数も見せたいなら都度計算はパフォーマンスが悪いので合計皿数もカラムに追加する。
  - https://teratail.com/questions/125938
  - あえて入れるなら注文テーブルに個数と皿数を集計した数を保存するカラムを追加

## 任意課題
- 論理モデルとは、システム化する業務のエンティティとリレーションを実装技術に依存しない形で行うモデリングである。
- 物理モデルとは、実装を考慮してエンティティをRDBMSのテーブルと1対1になるようモデリングしたものである。
- http://itref.fc2web.com/technology/entity_relationship_diagram.html

## 課題2
> シャリの大小も選べるようになりました。
- 寿司注文詳細テーブルにシャリサイズを追加


> 寿司ネタが毎月何個売れているのか知る必要が生じました。
- こちらも都度計算で求める法が良いと思うが、あえてもたせるなら注文テーブルに皿数の合計を集計した合計皿数テーブル。
個数を集計した合計個数カラムを追加。

## 課題3
> このお店ではお持ち帰りでの注文の他にUber Eatsを導入することにした。
> そこでその施策の効果を測るために注文毎のルート（お持ち帰り or Uber Eats）を知りたい。
- 注文テーブルに注文タイプを追加。将来的に注文の仕方によっての追加仕様があるなら注文カテゴリーテーブルにわけても良さそう？

> 顧客の来店回数を知りたい。そのために顧客は初来店時に名前と電話番号を店舗に伝える。
- 注文テーブルから名前・電話番号を切り出し、顧客テーブル追加。
- そこに来店回数をカラムを追加
- 注文テーブルに顧客IDを持たせる

# DBモデリング2

- ユーザーとワークスペースはユーザーワークスペースを通して多対多
- ユーザーとチャネルはユーザーチャネルを通して多対多
- ワークスペースは複数のチャネルを持つ
- ユーザーとチャネルはメッセージを通して多対多
- ユーザーとメッセージはスレッドメッセージを通して多対多

> メッセージとスレッドメッセージを横断的に検索できること（例えば「hoge」と検索したら、この文字列を含むメッセージとスレッドメッセージを両方とも取得できること）
メッセージとスレッドメッセージは親子関係にしているので横断検索可能

> 参加していないチャネルのメッセージ・スレッドメッセージは検索できないこと
メッセージがチャネルIDを持っているので検索ユーザーのチャネルIDで絞って検索
スレッドにもチャネルID持たせてもいいかも？親のメッセージが持っているからいらないかなと。。。

# DBモデリング3

- RDBでツリー構造を表現する方法

[![Image from Gyazo](https://i.gyazo.com/0898265e109720ca70c9a0725034564e.png)](https://gyazo.com/0898265e109720ca70c9a0725034564e)

> ディレクトリ構造は柔軟に変更可能。ディレクトリが移動してサブディレクトリになることもあり得る
上記の仕様なので閉包テーブルモデルを採用

[閉包テーブルの作り方](https://qiita.com/ymstshinichiro/items/b1825719c4fb274446cc#:~:text=%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6%E3%81%A7%E3%81%99%E3%80%82-,%E9%96%89%E5%8C%85%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB%E3%82%92%E4%BD%9C%E3%81%A3%E3%81%A6%E3%81%BF%E3%82%8B,-%E3%81%A7%E3%81%AF%E3%80%81%E5%89%8D%E6%8F%90%E3%82%92)

構造テーブルは、祖先と子孫の関係しか持っていません。
親と子の関係はこのテーブルから直接知ることはできません。
しかし、構造テーブルにツリーの深さを項目として持てば、もっとシンプルなクエリで取得することができます。
対象ノードの深さ±1である祖先(子孫)を取得することで直近の要素を取得できます。

# DBモデリング4

> Slackに登録している他のユーザ（複数可）宛にリマインダーを設定できる
複数のユーザーに送信できるように送信相手をリマインダーテーブルから切り出し

> 地道に正規表現でマッチしてます。 every 12 hours なら１２時間ごと、 every 3 monthsなら3ヶ月ごとなど、リマインダーの周期を決定します
周期タイプにenumで月・曜日・日・時間を保存。周期数に周期の数字を保存。曜日の場合は1〜7を保存して日曜を1にする。

# DBモデリング5

## 課題1
- 記事テーブルは更新日が一番新しい履歴IDを持つ
- 履歴テーブルには記事IDと本文と更新日を持つ。更新日で最新履歴を判定

## 課題2

> 「後から分析したいから履歴を残しておいて」など、 分析のみの用途でも履歴データをデータベースに保存しておく必要はあるのでしょうか？
回答：保存しておく必要はない。
理由：ログファイルから解析できるから

記事IDと更新日でプライマリキーにした。更新日が一番最新の記事が最新記事になる。

* メリット: テーブルが1つしかないため、テーブル管理が楽
* デメリット1: 最新記事一覧を取得するのがめんどくさい。
* デメリット2: この記事テーブルを参照するコメントテーブルを作った際に記事を更新した際にコメントテーブルの参照IDも変更しないといけない


# データベース設計のアンチパターンを学ぶ1

## 課題1

> 上記の例では、「投稿(Post)」に紐づけられた「タグ」を表現するために、投稿テーブルに「タグ」というカラムを持ち、その中に >"tagA, tagB, tagC"といった形でカンマ区切りで格納しています
>
> この設計だとどのような問題が生じるか、説明してみてください
>
> ヒント：「もし将来こんな仕様変更があったら、どれだけ大きなスキーマ変更になるだろうか？」「今の作りだと表現できないユースケースがあるのでは？」など、具体的なケースを沢山仮定して考えてみると良いかもしれません！
- 特定のtag_idを持つ行の検索・結合が複雑になるの
  - インデックスが適用されないので、検索・結合が遅い
  - クエリが利用するミドルウェアに依存する

```sql
SELECT * FROM Posts
 WHERE
  tags LIKE '%,1,%' -- カンマ区切りの内部に1を含む
 OR
  tags LIKE '1,%' -- カンマ区切りの先頭に1を含む
 OR
  tags LIKE '%,1' -- カンマ区切りの末尾に1を含む
```

- 集約関数が使用できないため、COUNT, SUM, AVGなどの集計のクエリが複雑になる
- tagを1つ削除する場合に元のtagsと更新したtagsの保存の2操作が必要になる

## 課題3

- ブログの共同編集者の設定
  - auther_id に複数のautherのIDをいれる

- ECサイトのカート
  - カートテーブルに複数の商品IDをいれる

- チャットのワークスペースに複数のユーザーを持つアプリ
  - ユーザーのIDを複数いれる

# データベース設計のアンチパターンを学ぶ2

## 課題1
- あるタグの付いたPostを検索する場合は全てのカラムに対する条件を OR でつなぐ必要がある
- タグを既存のPostに追加するときは、どのカラムが開いているか事前に確認しなければなりません。
- 同一のタグが一つのPostに追加されてしまう
- 最大で3つしかタグ追加できない

## 課題3
- ユーザーが複数の電話番号をもつ場合にユーザーテーブルにaddress_1のようなカラムが複数ある
- 商品がカテゴリーを複数もつ場合に商品テーブルにcategory_1のようなカラムが複数ある
- ユーザーが複数のルームに入れるチャットアプリにユーザーテーブルにroom_1のようなカラムが複数ある

# データベース設計のアンチパターンを学ぶ3

## 課題1
- 外部キーの宣言が出来ないため、 参照整合性制約 を定義できない
- JOINを行う場合に動的にテーブルを選択することはできないので全てのテーブルを指定しなければいけない

## 課題3
- 管理ユーザーテーブルと一般ユーザーテーブルによってユーザを管理している時に、それらのユーザのログをユーザログテーブル(user_logs)でまとめて記録したい場合
- 記事テーブルと写真テーブルを管理している時に、どちらにも「コメント」をつけたい場合

# データベース設計のアンチパターンを学ぶ4

## 課題1
- ツリー全体、もしくはある要素のサブツリーが取得しづらい（例：あるコメントのスレッド総数などが取得できない）
  - 要素の取得に1階層ごとにJOINしないと取得できない
  - 階層がどこまであるかわからないので取得できる階層が固定される

- 子が存在する要素を削除した際に整合性を取りづらい。
  - 削除する時に参照整合性のために子要素から順に取得して削除しなければならない
  - 親:1, 子:2, 孫:3のようなデータが有り2を削除したい場合に参照整合性のために3の親を1に変更してから2を削除しなければならない
  - 論理削除なら上記の心配はない

## 課題3
- esa, notionなどの階層構造型のドキュメント管理ツール
- 掲示板アプリのスレッドコメントなど


```sql
SELECT
  c.*
FROM
  Comments c
INNER JOIN
  TreePaths t
ON
  c.id = t.descendant_id
WHERE
  t.ancestor_id = 1;
```

<h5>追加</h5>
親コメント2（ID=5）に対するコメントを追加した場合

```sql
DELETE FROM
  TreePaths
WHERE
  descendant_id IN 4;
DELETE FROM
  TreePaths
WHERE
  ancestor_id IN 4;
```

# データベース設計のアンチパターンを学ぶ5

## 課題1
> 例えば商談の数が増えたらどうなるでしょうか？
- 面談の数が増えたらレコードを新しく作るしかなく、同じ顧客なのに新しい顧客として表現するしかない。
> 仮に面談を3回実施して、1回目の面談日時を知りたい時はどうすれば良いのでしょうか？
- 現状のテーブルだけだと、1回目と3回目の顧客のつながりがないため、新しくCustomerRelationテーブルを作り、閉包モデルの形式で親子関係を保存。NewCustomerとJoinして一番若いIDの面談日時を取得
> 例えば一度成約した後に解約し、後にまた同じ人が成約したらどうなるでしょうか？
- NewCustomerに新しくレコードが登録される
## 課題3
- 求人サイト。求職者のステータスや申込日、面談日などを1テーブルで管理する


# データベース設計のアンチパターンを学ぶ6

## 課題1
- ステータスで検索しようとしても、ステータスを取得するとenum定義等を含む値が帰ってくるためそのままだと使用できない
- メタデータので意義を取得する場合はMySQLではシステムビューのinformation_schemaを検索する
```sql
SELECT
  column_type
FROM
  information_schema.columns
WHERE
  table_name = 'Student'
AND
  column_name = 'status';
+-----------------------------------+
| column_type                       |
+-----------------------------------+
| enum('在学中', '卒業', '停学中')     |
+-----------------------------------+
```

- enumの値やcheck制約を追加、削除する構文はないため新たな値の組合せで列を再定義するしかないため、新しいステータスを追加しづらい
- 値の変更に手間がかかる。
  - 既存のステータスは削除できないため、下記の3ステップが必要になる
  1. 変更後のステータスを追加
  2. 変更元のステータスを変更後のステータスに更新
  3. 変更元のステータスを削除
- データベースの種類ごとに使用が違うため、移植が困難

# データベース設計のアンチパターンを学ぶ7

## 課題1
- 常にWHERE句が必要
  - 上記の影響でdefault_scopeを使うと既存のコードにバグが出る可能性やdestroy_allをつかってしまい物理削除してしまう可能性がある。論理削除済みのものを検索する場合に難しい
  - 削除フラグを含めたユニーク制約が必要になる場合がある。右記ができていないとLIMIT 1などの場当たり的なクエリが必要になる
  - 全てのテーブルに論理削除がある場合はINNER_JOINをするとWHEREがJOINしたテーブル数必要になる
- 削除以外の状態が出たときにまた別のフラグが追加されてしまう

## 課題3
- 社員のデータを扱っているサービスで社員の退職を表現する場合

# データベース設計のアンチパターンを学ぶ8

## 課題1
- 商品コードを変更すると、商品テーブルを外部参照しているすべてのテーブル（例えば受注明細テーブル）上の商品コード値を洗い替えなければならない
- 主キーを「商品コード」から「会社コード＋商品コード」に変更した場合、商品テーブルを外部参照しているすべてのテーブルの構造に変更が必要となる

## 課題2
- 主キーを業務上は意味を持つ値ではないが、システム的に一意な値をとるようオートインクリメントなどで連番を振るサロゲートキーにする


## 課題3
- 社員を管理するサービスで社員コードを主キーにする場合

# インデックスを理解する
## 課題1
- インデックスとは、テーブルにある情報を検索する場合に「どこに何があるか」をわかりやすくする索引のことです。インデックスが設定されていない場合の検索では、テーブルの最初から順番に1件ずつ探すため、時間がかかります。
> テーブルのある行へのアクセスを集合住宅での荷物の配達に例えると、インデックスの有無は以下のように表現することができます。
> ・インデックス無　集合住宅を歩き回り、各戸の表札を見て配達先かどうか確かめる
> ・インデックス有　住民の情報が書かれた見取り図で配達先を確認して向かう
https://products.sint.co.jp/siob/blog/index

> 先輩エンジニアに「ちゃんとslow query logを調べた？」と聞かれました。なぜ調べる必要があるのでしょうか？
- indexが多すぎても検索に時間がかかり、slow queryになる可能性があるためslow query logを調べる必要がある
> INDEXを貼ったカラムはメモリ上にのるため、貼りすぎるとMySQL以外のプロセスを圧迫し、メモリが溢れてしまう危険があります。
https://blog.engineer.adways.net/entry/2017/01/20/190000
> インサート時にINDEXの再構築がたくさん走り、書き込み性能の劣化を招くからです。INDEXがある方が一般的に読み込みは速いですが、無い方が書き込みは速いと言うトレードオフの関係
https://zenn.dev/koduki/articles/d3e8984f420b370681f9


- ガーデナリティとはカラムに格納されているデータの種類がどのくらいあるのか(カラムの値の種類の絶対値)
https://bbh.bz/2019/12/05/column-to-be-indexed/#i-3

- カバリングインデックスとはクエリが必要とするカラムがすべてインデックスに含まれている場合、インデックスだけを読めば良いのでとても速い
普通のクエリの実行の流れは以下のようになっています。
1. インデックスを使って一致するレコードを探し、データへのポインタを取得
2. 対応するデータへのポインタをたどる
3. レコードを返す
カバリングインデックスが使用できる時には、クエリから要求される全てのフィールドがインデックスに含まれてしまっています。つまり、上の流れの2がスキップできるので、以下の流れで実行できます。
1. インデックスを使って一致するレコードを探す
2. レコードを返す

## 課題22
> WHERE句を1つだけ含むSELECTクエリを3つ考えてください

```sql
SELECT * FROM salaries WHERE salary="40000";
95373 rows in set (0.45 sec)

SELECT * FROM employees WHERE birth_date='1953-09-02';
63 rows in set (0.10 sec)

SELECT * FROM employees WHERE first_name='Aamer';
228 rows in set (0.09 sec)
```

> 上記のSELECTクエリを高速化するインデックスを作成してください
```sql
create index birth_date_index on employees(birth_date);

create index salary_index on salaries(salary);

create index first_name_index on employees(first_name);
```

> インデックスを使って検索した場合どれだけ検索速度に差が出るか、測定してください
```sql
SELECT * FROM salaries WHERE salary="40000";
95373 rows in set (0.18 sec)

SELECT * FROM employees WHERE birth_date='1953-09-02';
63 rows in set (0.00 sec)

SELECT * FROM employees WHERE first_name='Aamer';
228 rows in set (0.00 sec)
```

> EXPLAINを使って、ちゃんとインデックスが使われていることを証明してください
```sql
EXPLAIN SELECT * FROM salaries WHERE salary="40000";
+----+-------------+----------+-----------------------------------------------------------------------------+------+---------------+--------------+---------+-------+-------+----------+-------+
| id | select_type | table    | partitions                                                                  | type | possible_keys | key          | key_len | ref   | rows  | filtered | Extra |
+----+-------------+----------+-----------------------------------------------------------------------------+------+---------------+--------------+---------+-------+-------+----------+-------+
|  1 | SIMPLE      | salaries | p01,p02,p03,p04,p05,p06,p07,p08,p09,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19 | ref  | salary_index  | salary_index | 4       | const | 95373 |   100.00 | NULL  |
+----+-------------+----------+-----------------------------------------------------------------------------+------+---------------+--------------+---------+-------+-------+----------+-------+
1 row in set, 1 warning (0.01 sec)


EXPLAIN SELECT * FROM employees WHERE first_name='Aamer';
+----+-------------+-----------+------------+------+------------------+------------------+---------+-------+------+----------+-------+
| id | select_type | table     | partitions | type | possible_keys    | key              | key_len | ref   | rows | filtered | Extra |
+----+-------------+-----------+------------+------+------------------+------------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | employees | NULL       | ref  | first_name_index | first_name_index | 44      | const |  228 |   100.00 | NULL  |
+----+-------------+-----------+------------+------+------------------+------------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)


EXPLAIN SELECT * FROM employees WHERE birth_date='1953-09-02';
+----+-------------+-----------+------------+------+------------------+------------------+---------+-------+------+----------+-------+
| id | select_type | table     | partitions | type | possible_keys    | key              | key_len | ref   | rows | filtered | Extra |
+----+-------------+-----------+------------+------+------------------+------------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | employees | NULL       | ref  | birth_date_index | birth_date_index | 3       | const |   63 |   100.00 | NULL  |
+----+-------------+-----------+------------+------+------------------+------------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

## 課題3

```sql
-- index削除前
insert into employees values (500000, '1995-04-08', 'Yasunari', 'Kainuma', 'M', '2022-01-23');
Query OK, 1 row affected (0.01 sec)

-- index削除後
insert into employees values (500000, '1995-04-08', 'Yasunari', 'Kainuma', 'M', '2022-01-23');
Query OK, 1 row affected (0.00 sec)
```

> NDEXがある場合とない場合で、INSERTにかかる時間にはどのような変化があったでしょうか？
- テーブルにインデックスがある場合、データベースはインデックスを使って新しいエントリを見つけられるようにしなければなりません。
- 新しいエントリはテーブルの全てのインデックスにも追加されます。従って、インデックスの数はinsert文の実行コストの乗数になります。

> 上記の処理速度の変化はDELETE文にも生じるでしょうか？
インデックスから参照を削除し、行の削除を行うためDELETEの実行時間もインデックスの有無で実行時間に差が出る。
しかし、インデックスがないと、データベースは削除すべき行を見つけるのにフルテーブルスキャンを実行しなくてはなりません。
つまり、行の削除自体は高速ですが、削除すべき行を見つけるのは非常に遅いという状況になる

## クイズ
- 1952年生まれの従業員数を集計してください
- 入社年度ごとの従業員数を集計してください
- 従業員の男女比を集計してください
