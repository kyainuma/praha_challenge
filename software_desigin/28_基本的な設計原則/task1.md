## SOLID原則の各要素を、業務経験1年目のITエンジニアに伝わるように説明してください。これらを守ることで、どのようなメリットがあるのでしょうか？

### S (Single Responsibility)　単一責任の原則
- 例えば、あるクラスがユーザーとオペレータと管理者向けの機能を全部持っていると複雑になりすぎるからやっちゃダメだから、単一のアクターに対して機能提供できるように分割しましょうという原則
  - ユーザー向けにコードを改修したい場合に、影響範囲の調査やテストの改修をオペレータや管理者向けの機能も持っているため、オペレータや管理者にも影響が無いかどうか？という調査やテストが必須になる
- クラスは、単一の責任を持つべきという原則
  - クラスに多くの責任があると、その責任の1つに変更を加えると、知らないうちに他の責任に影響を与える可能性があり、バグが発生する可能性が高くなる
  - 変更の結果としてバグが発生しても、他の無関係な動作に影響を与えないように、動作を分離することが目的

### O (Open-Closed)　オープン・クローズドの原則
- 変更が発生した場合に、既存のコードには修正を加えずに、新しくコードを追加するだけで対応できるような設計にする原則
- クラスは、拡張にはオープンで、変更にはクローズドであるべきという原則
  - クラスの現在の動作を変更すると、そのクラスを使用するすべてのシステムに影響を与える
  - クラスでより多くの関数を実行したい時、理想的な方法は、既存の関数に追加することであり、変更しないこと
  - そのクラスが使用されている場所でバグが発生するのを避けるため、クラスの既存の動作を変更することなく、クラスの動作を拡張することが目的

### L (Liskov Substitution)　リスコフの置換原則
- 派生型（サブクラス）は、その基底型（スーパークラス）と置換可能でなければならないという原則
- SがTのサブタイプである場合、プログラム内のT型のオブジェクトをS型のオブジェクトに置き換えても、そのプログラムの特性は何も変わらないという原則
  - 子クラスが親クラスと同じ動作を実行できない場合、バグになる可能性がある
  - クラスから別のクラスを作ると、クラスが親になり、新しいクラスが子になります。子クラスは、親クラスができることをすべてできる必要があり、これを継承と呼ぶ
  - 子クラスは、親クラスと同じリクエストを処理し、同じ結果か、同様の結果を提供できなければならない
  - 子クラスがこれらの要件を満たさない場合、子クラスが大きく変更され、この原則に違反することになる
  - 親クラスやその子クラスがエラーなしで同じ方法で使用できるように、一貫性を保つことが目的

### I (Interface Segregation)　インターフェイス分離の原則
- インターフェースを複雑にしてはいけないので、分離できるものは分離しましょうという原則
  - インターフェースの利用者の立場に立って、インターフェース自体、利用用途に応じた最小限の規則だけを決めておくか、それぞれのメソッドが独立して使えるようにすべき
- クライアントが使用しないメソッドへの依存を、強制すべきではないという原則
  - クラスに使用しない動作を実行させようとするのは、無駄が多く、クラスにその動作を実行する機能がない場合、予期しないバグが発生する可能性がある
  - クラスは、その役割を果たすために必要な動作のみを実行する必要があり、それ以外の動作は完全に削除するか、将来的に他のクラスで使用する可能性がある場合は別の場所に移動すべき
  - 動作のセットをより小さく分割して、クラスが必要なもののみを実行することが目的

### D (Dependency Inversion)　依存性逆転の原則
- 設計上望ましい依存の方向性と、素直に実装しようとしたときの方向性は矛盾しちゃうので、そこをテクニックでカバーして逆転させると、じつはスッキリと望ましい設計になるよという原則
  - 依存する側がモジュールを直接呼び出すのではなく、抽象クラスやインターフェースを使い「抽象」に依存しましょう
- 上位モジュールは、下位モジュールに依存してはならない。どちらも抽象化に依存すべき
- 抽象化は詳細に依存してはならない。詳細が抽象化に依存すべき
  - 上位モジュール（またはクラス）：ツールを使って動作を実行するクラス
  - 下位モジュール（またはクラス）：動作を実行するために必要なツール
  - 抽象化：2つのクラスをつなぐインターフェイス
  - 詳細：ツールの動作方法
  - クラスは動作を実行するために使用するツールと融合すべきではなく、ツールがクラスに接続できるようにするインターフェイスと融合すべき
  - クラスもインターフェイスも、ツールの動作方法を知るべきではありません。ただし、ツールはインターフェイスの仕様を満たす必要がある
  - インターフェイスを導入することにより、上位レベルのクラスが下位レベルのクラスに依存するのを減らすことが目的

## 参考記事
[イラストで理解するSOLID原則](https://qiita.com/baby-degu/items/d058a62f145235a0f007)
[よくわかるSOLID原則1: S（単一責任の原則）](https://note.com/erukiti/n/n67b323d1f7c5)
[リスコフの置換原則（LSP）をしっかり理解する](https://qiita.com/yuki153/items/142d0d7a556cab787fad)

## 単一責任の原則と、単純にファイルを細かなファイルに分解することには、どのような違いがあるでしょうか？
- 単一責任の原則・・・単一の責任をもつクラスをつくることが目的
- ファイル分割　・・・1つのファイルの記載料を少なくするのが目的
- 同じクラスのファイルを細かなファイルに分割しても、1つのクラスに多くの責任があることに変わりないため、単一責任の原則に従っていることにはならない

## Open-Closed-Principleの実例
### 違反例
- 猫と犬以外に新たに動物を追加したいとき、AnimalSound関数に対して条件分岐を追加しなければいけない
- 既存の成果物（AnimalSound関数）に対して、コードを変更せざるを得ない
```ts
class Animal {
    animalName: string
    constructor(name: string) {
        this.animalName = name
    }
}

const AnimalSound = (animal: Animal[]) => {
    for (let i = 0; i < animal.length; i++) {
        if (animal[i].animalName === 'cat') console.log('meow')
        if (animal[i].animalName === 'dog') console.log('bowwow')
    }
}

const animals: Animal[] = [new Animal('cat'), new Animal('dog')]

AnimalSound(animals) // meow bowwow
```

### 遵守例
- 各動物に対するクラスを作成し、インターフェースを実装
- 新しい動物を追加するときは、新しいクラスを作成するだけになり、既存のAnimalSound関数を変更しなくても良い
```ts
interface IAnimal {
   makeSound(): string
}

class Cat implements IAnimal {
    makeSound = () => 'meow'
}

class Dog implements IAnimal {
    makeSound = () => 'bowwow'
}

const AnimalSound = (animals: IAnimal[]) => {
    for (let i = 0; i < animals.length; i++) {
        console.log(animals[i].makeSound())
    }
}

const animals = [new Cat(), new Dog()]

AnimalSound(animals) // meow bowwow
```

## リスコフの置換原則に違反した場合、どのような不都合が生じるでしょうか？
- リスコフの置換原則に反して派生型が基本型と置換可能でなかった場合、その派生型を処理する場合だけは呼び出し元で特殊な処理をしなければならない
- 処理を無駄に複雑化させるコードになり、呼び出し元の処理に修正を加えなければ機能を拡張できないという意味では、オープンクローズドの原則にも反している

### 参考記事
[SOLID原則とは？SOLIDのL、リスコフの置換原則をイラストでわかりやすく解説](https://emb-sw-eng.com/solid_l/)

## インターフェースを用いる事で、設計上どのようなメリットがあるでしょうか？
- 役割ごとにカテゴライズされた各レイヤー間にインターフェース（契約）を設けることによって、各レイヤー間を疎結合にし（依存度を低くし）、変更に強いアプリケーション作ることができる

### 参考記事
インターフェースの例がわかりやすかった
> 一般的に、インターフェースとは「契約」と言われることが多いです。
日常生活で身近な契約って何だろて考えたときに、電力会社との契約とかがわかりやすいかなと思います。
電力会社と契約済みであれば、極端ですが「電気ちょーだい」というと電気が供給されると思います。
この時、供給された電気はどこでどのように生み出されたのか意識したことはありませんよね？（原子力発電なのか、火力発電なのか、風力発電なのか）
そして、もしかしたら、将来的に原子力発電は廃止されて、それに変わる新たな発電方式が生み出されるかもしれません。その場合でも今まで通り「電気ちょーだい」というと電気が供給されるはずです。
このように、**利用者は、契約（インターフェース）によって、電源（実装）を意識しなくても、形式的に電気（メソッド）を利用することができます。**これがインターフェースの主な存在意義だと思います。

[インターフェースって何のメリットがあるんですか？](https://teratail.com/questions/70213)

## どんな時に依存性の逆転を用いる必要が生じるのでしょうか？
- モジュールAがモジュールBの実装を参照している場合
  - モジュールBの変更がモジュールAに影響を及ぼす可能性がある
  - モジュールBの改修を行う際は、モジュールBの実装に依存しているモジュールAに影響がないかなどの調査を行わねばならず、そのぶん工数がかかる

### 参考記事
[TypeScriptでSOLID原則〜依存性逆転の原則〜](https://www.membersedge.co.jp/blog/typescript-solid-dependency-inversion-principle/)

## デメテルの法則
### デメテルの法則とは何でしょうか？
```js
`${message.user.name}さん : `
```
デメテル曰く、プログラミングの世界では「知りすぎている」のは罪なのです

この場合messageはuser_idは知っていて紐づいている。だけどuser自体の事は知らないし、そのnameなんて事は知らないはず

### デメテルの法則を守ることで、どのようなメリットがあるのでしょうか？
- ユニットテストが楽になる
  - ユニットテストを行う際に関係しているクラスが少ない（結合度が低い）と、1回のテストで最低限の数のモックになる
- 改修が楽になる
  - 結合度が低いということは、知っている（依存している）クラスの仕様が変わっても、影響を受けにくい

### これだけでは特にコードの保守性に対して効果が無いことを説明してあげてください
- getter/setterの中でメソッドチェーン（._userId）して、オブジェクトが_userIdを知っている前提になっているため、呼び出し元のオブジェクトが変更されたときに、Purchaseクラスでもバクが出る

### デメテルの法則を守ることにはどのような意味/効果があるのでしょうか？
- 疎結合になり変更に強いコードになる
- テストの変更箇所が少なくなる

### 参考記事
[お前のデメテルの法則は間違っている ～getter/setterの必要性～](https://tech-blog.rakus.co.jp/entry/20200701/programming)
[デメテルの法則を厳密に守るにはどうすればいいの？](https://qiita.com/br_branch/items/37cf71dd5865cae21401)
