# インデックスを理解する
## 課題1
- インデックスとは、テーブルにある情報を検索する場合に「どこに何があるか」をわかりやすくする索引のことです。インデックスが設定されていない場合の検索では、テーブルの最初から順番に1件ずつ探すため、時間がかかります。
> テーブルのある行へのアクセスを集合住宅での荷物の配達に例えると、インデックスの有無は以下のように表現することができます。
> ・インデックス無　集合住宅を歩き回り、各戸の表札を見て配達先かどうか確かめる
> ・インデックス有　住民の情報が書かれた見取り図で配達先を確認して向かう
https://products.sint.co.jp/siob/blog/index

> 先輩エンジニアに「ちゃんとslow query logを調べた？」と聞かれました。なぜ調べる必要があるのでしょうか？
- indexが多すぎても検索に時間がかかり、slow queryになる可能性があるためslow query logを調べる必要がある
> INDEXを貼ったカラムはメモリ上にのるため、貼りすぎるとMySQL以外のプロセスを圧迫し、メモリが溢れてしまう危険があります。
https://blog.engineer.adways.net/entry/2017/01/20/190000
> インサート時にINDEXの再構築がたくさん走り、書き込み性能の劣化を招くからです。INDEXがある方が一般的に読み込みは速いですが、無い方が書き込みは速いと言うトレードオフの関係
https://zenn.dev/koduki/articles/d3e8984f420b370681f9


- ガーデナリティとはカラムに格納されているデータの種類がどのくらいあるのか(カラムの値の種類の絶対値)
https://bbh.bz/2019/12/05/column-to-be-indexed/#i-3

- カバリングインデックスとはクエリが必要とするカラムがすべてインデックスに含まれている場合、インデックスだけを読めば良いのでとても速い
普通のクエリの実行の流れは以下のようになっています。
1. インデックスを使って一致するレコードを探し、データへのポインタを取得
2. 対応するデータへのポインタをたどる
3. レコードを返す
カバリングインデックスが使用できる時には、クエリから要求される全てのフィールドがインデックスに含まれてしまっています。つまり、上の流れの2がスキップできるので、以下の流れで実行できます。
1. インデックスを使って一致するレコードを探す
2. レコードを返す

## 課題2
> WHERE句を1つだけ含むSELECTクエリを3つ考えてください

```sql
SELECT * FROM salaries WHERE salary="40000";
95373 rows in set (0.45 sec)

SELECT * FROM employees WHERE birth_date='1953-09-02';
63 rows in set (0.10 sec)

SELECT * FROM employees WHERE first_name='Aamer';
228 rows in set (0.09 sec)
```

> 上記のSELECTクエリを高速化するインデックスを作成してください
```sql
create index birth_date_index on employees(birth_date);

create index salary_index on salaries(salary);

create index first_name_index on employees(first_name);
```

> インデックスを使って検索した場合どれだけ検索速度に差が出るか、測定してください
```sql
SELECT * FROM salaries WHERE salary="40000";
95373 rows in set (0.18 sec)

SELECT * FROM employees WHERE birth_date='1953-09-02';
63 rows in set (0.00 sec)

SELECT * FROM employees WHERE first_name='Aamer';
228 rows in set (0.00 sec)
```

> EXPLAINを使って、ちゃんとインデックスが使われていることを証明してください
```sql
EXPLAIN SELECT * FROM salaries WHERE salary="40000";
+----+-------------+----------+-----------------------------------------------------------------------------+------+---------------+--------------+---------+-------+-------+----------+-------+
| id | select_type | table    | partitions                                                                  | type | possible_keys | key          | key_len | ref   | rows  | filtered | Extra |
+----+-------------+----------+-----------------------------------------------------------------------------+------+---------------+--------------+---------+-------+-------+----------+-------+
|  1 | SIMPLE      | salaries | p01,p02,p03,p04,p05,p06,p07,p08,p09,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19 | ref  | salary_index  | salary_index | 4       | const | 95373 |   100.00 | NULL  |
+----+-------------+----------+-----------------------------------------------------------------------------+------+---------------+--------------+---------+-------+-------+----------+-------+
1 row in set, 1 warning (0.01 sec)


EXPLAIN SELECT * FROM employees WHERE first_name='Aamer';
+----+-------------+-----------+------------+------+------------------+------------------+---------+-------+------+----------+-------+
| id | select_type | table     | partitions | type | possible_keys    | key              | key_len | ref   | rows | filtered | Extra |
+----+-------------+-----------+------------+------+------------------+------------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | employees | NULL       | ref  | first_name_index | first_name_index | 44      | const |  228 |   100.00 | NULL  |
+----+-------------+-----------+------------+------+------------------+------------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)


EXPLAIN SELECT * FROM employees WHERE birth_date='1953-09-02';
+----+-------------+-----------+------------+------+------------------+------------------+---------+-------+------+----------+-------+
| id | select_type | table     | partitions | type | possible_keys    | key              | key_len | ref   | rows | filtered | Extra |
+----+-------------+-----------+------------+------+------------------+------------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | employees | NULL       | ref  | birth_date_index | birth_date_index | 3       | const |   63 |   100.00 | NULL  |
+----+-------------+-----------+------------+------+------------------+------------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

## 課題3

```sql
-- index削除前
insert into employees values (500000, '1995-04-08', 'Yasunari', 'Kainuma', 'M', '2022-01-23');
Query OK, 1 row affected (0.01 sec)

-- index削除後
insert into employees values (500000, '1995-04-08', 'Yasunari', 'Kainuma', 'M', '2022-01-23');
Query OK, 1 row affected (0.00 sec)
```

> NDEXがある場合とない場合で、INSERTにかかる時間にはどのような変化があったでしょうか？
- テーブルにインデックスがある場合、データベースはインデックスを使って新しいエントリを見つけられるようにしなければなりません。
- 新しいエントリはテーブルの全てのインデックスにも追加されます。従って、インデックスの数はinsert文の実行コストの乗数になります。

> 上記の処理速度の変化はDELETE文にも生じるでしょうか？
インデックスから参照を削除し、行の削除を行うためDELETEの実行時間もインデックスの有無で実行時間に差が出る。
しかし、インデックスがないと、データベースは削除すべき行を見つけるのにフルテーブルスキャンを実行しなくてはなりません。
つまり、行の削除自体は高速ですが、削除すべき行を見つけるのは非常に遅いという状況になる

## クイズ
- 1952年生まれの従業員数を集計してください
- 入社年度ごとの従業員数を集計してください
- 従業員の男女比を集計してください
